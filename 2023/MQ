一、rocketMQ:
1、普通集群中，异步同步效率更高，但是有丢失消息的风险，同步同步就不会丢消息

Kafka：
通常都是用在允许少量丢失的场景，acks ：参数 0,1，all

二、Mq消息存盘不丢失：
同步刷盘，安全性更高，效率就低，异步刷盘，效率高，但有可能丢失消息

MQ消费者消费消息不丢失：
RocketMQ：使用默认的方式消费就行，不要采用异步方式

三、消息消费的幂等性：就是消费者重复消费消息的过程，所有MQ产品并没有提供主动解决幂等性的机制，需要由消费者自行控制
RocketMQ：给每个消息分配了一messageId，这个id作为消费者判断幂等的依据，这种方式不要建议。最好的方式就是自己带一个有业务标识的ID，来进行幂等判断，统一ID分配

四、消息顺序
 MQ只需要保证局部有序，不需要保证全局有序

五、消息高效读写
  Kafka和Rocket都是通过零拷贝（select，poll，epoll）技术来优化文件读写，零拷贝（文件不经过用户空间，直接在内核空间进行拷贝，这就是mmap）
  文件传输过程中，直接使用DMA
  kafka，还有写时复制，批量写文件
  mmap适合比较小的文件，通常文件大小不要超过1.5-2.0G
   RocketMQ使用mmap对文件进行读写，commitlog，1G大小，
   在kafka当中，他的index日志文件也是通过mmap来进行读写的，其他日志文件没有使用零拷贝，kafka使用transfile

六、MQ保证分布式事务的最终一致性
MQ中，生产者：100%的消息投递，事务消息机制
     消费者：完全消费：不出异常，唯一ID + 业务自己实现幂等

MQ作用，实现一个单机的队列数据结构，高效可扩展，扩展为分布式队列，分布式集群管理

  记录队列消费进度，基于topic定制消息路由策略，发送者路由策略，消费者与队列对应关系，消费者路由策略
  网络通信，netty
  规划日志文件，高效读写，零拷贝，顺序写，服务重启后，还原运行现场
  高级功能，死信队列，延迟队列，事务消息