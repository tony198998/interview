1、Spring 容器本身并没有提供Bean的线程安全策略，因此，也可以说Spring容器中的bean不是线程安全的

    Spring中的作用域： 1、sington 2、prototype：为每个Bean创建实例  3、request：为每个request请求创建一个实例，请求完成后失效

    线程安全问题：
    1、对于prototype作用域，每次生成一个新的对象，不存在线程安全问题
    2、sington：默认就是线程不安全的，大部分bean，是无状态的，不需要保证线程安全，无状态表示这个实例没有属性对象，不能保存数据，比如controller，service，dao
    3.保证线程安全，可以将Bean的作用域改成prototype，
    4、也可以ThreadLocal来解决线程安全问题，每个线程创建变量副本，每个线程只操作自己的副本变量


循环依赖：
多个对象之间存在循环的引用关系
三级缓存，@Lazy，懒加载


Spring事务：
1、编程式事务可以使用TransactionTemplate
2、声明式事务：是Spring在Aop基础上提供的事务实现机制，只能控制方法级别，不能控制代码级别
spring对事务定义了不同的传播级别：
 1、PROPAGATION_REQUIRED：默认传播行为，当前没有事务，就创建一个事务，如果存在事务，就加入该事务
 2、PROPAGATION_SUPPORTS：如果存在事务，就加入该事务，不存在，就以非事务方式运行
 3、PROPAGATION_MANDATORY：如果存在事务，就加入该事务，不存在抛出异常
 4、PROPAGATION_REQUIRES_NEW：无论是否存在事务，都创建新事务
 5、PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果存在事务，就抛出异常
 。。
 。。
 一共7种


 隔离級別：
 1、ISOLATION_DEFAULT:使用数据库默认的事务隔离级别
 2、ISOLATION_READ_UNCOMMITTED:读未提交，允许事务读取其他未提交的数据
 3、ISOLATION_READ_COMMITTED:读已提交，允许事务读取其他事务已经提交的数据
 4、ISOLATION_REPEATABLE_READ:可重复读，同一个事务内，任意时刻读取的数据都一致
 5、ISOLATION_SERIALIZABLE:串行化，所有事务依次执行
