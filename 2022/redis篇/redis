1、RDB：写redis日志，平均间隔一段时间写内存操作，效率高，安全低
2、AOF：append only file:追加日志，每追加一次，就会写内存操作，效率低，安全性高

redis非常看重网络带宽和低延迟，
采用reactor模式，内部采用事件分发处理器，监听多个socket，事件分发处理  器是单线程的，所以redis是单线程
3：过期键的删除策略：
  get的时候，发现过期，就删除
  内部起一个定时线程，发现过期就删除
4：大value对象，对性能的影响，由于是单线程，大对象存储，查询，IO流操作都非常耗时，耗性能
优化方式：压缩大对象，压缩后再存储，取出来的时候，再解压缩
        将大对象拆分成多个小对象，多次存储

5：其他优化：存储数字占用的内存小

内存淘汰：noeviction（默认策略）对于写请求不再提供服务，直接返回错误
volite-ttl:设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越先被淘汰

LRU算法进行内存淘汰：（Least Recently Used）,即最近最少使用，是一种缓存置换算法（如果一个key值最近一段时间内没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉）
每个key额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间，每次选5个key进行内存淘汰
redis3.0:维护一个16字节大小的池子，根据访问时间进行排序，最早访问的进池子中，把最近访问的淘汰
