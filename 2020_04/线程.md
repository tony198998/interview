1、ThreadPoolExecutor执行顺序：
     线程池按以下行为执行任务
 
当线程数小于核心线程数时，创建线程。
当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
当线程数大于等于核心线程数，且任务队列已满
若线程数小于最大线程数，创建线程
若线程数等于最大线程数，抛出异常，拒绝任务

2、线程中不允许使用stop()，suspend()方法
stop（）：其实stop方法天生就不安全，因为它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完了，  
并且还会释放这个线程所持有的所有的锁对象；如果A向B转账500，A少了500，马上中断，其余线程继续执行，
造成A无端少了500

suspend():调用这个方法线程阻断，但不会释放对象的锁，调用该线程的resume()方法才会唤起该线程，如果B线程在获取
A线程的锁之后才去调用resume（）方法，但是锁却被A线程占据，迫使B也无法获取锁，无法调用A线程的resume()方法，
这样就会形成死锁。

3、sleep（）和wait（）区别
    1.sleep是线程中的方法,但是wait是Object中的方法。
    2.sleep方法不会释放lock,但是wait会释放,而且会加入到等待队列中。
    3.sleep方法不依赖于同步器synchronized,但是wait需要依赖synchronized关键字。
    4.sleep不需要被唤醒(休眠之后退出阻塞),但是wait需要(不指定时间需要被别人中断)。