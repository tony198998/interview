其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，
相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，
从JDK1.7版本的ReentrantLock+Segment+HashEntry，
到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。

1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。
2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。
JDK1.8采用CAS+Synchronized保证线程安全。
3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）
。4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，
会将链表转化为红黑树进行存储。
5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。


CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。
在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，
等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。
而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。
如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。
CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，
那么a线程需要自旋，到下次循环才有可能机会执行。