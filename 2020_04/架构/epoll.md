epoll机制详解
大牛的详解

epoll详解
什么是epoll?
epoll是为处理大批量句柄而作了改进的poll, 是性能最好的多路I/O就绪通知方法;
只有三个系统调用: epoll_create, epoll_ctl, epoll_wait;
epoll_ctl - epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型;
epoll的工作原理
epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值;
你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销;
另一个本质的改进在于epoll采用基于事件的就绪通知方式;
在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描;
而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知;
epoll的两种工作方式
水平触发(LT)
相当于速度比较快的poll;
LT(level triggered)是epoll缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作;
如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点;
传统的select/poll都是这种模型的代表．
边缘触发(ET)
用了EPOLLET标志;
相当于非阻塞的读;
ET (edge-triggered)是高速工作方式，只支持no-block socket，它效率要比LT更高;
ET与LT的区别在于，当一个新的事件到来时，ET模式下当然可以从epoll_wait调用中获取到这个事件，可是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字中没有新的事件再次到来时，在ET模式下是无法再次从epoll_wait调用中获取这个事件的;
而LT模式正好相反，只要一个事件对应的套接字缓冲区还有数据，就总能从epoll_wait中获取这个事件;
LT模式下开发基于epoll的应用要简单些，不太容易出错。而在ET模式下事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应;
epoll的优点